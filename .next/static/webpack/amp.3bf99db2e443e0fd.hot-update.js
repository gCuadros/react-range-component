"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/defineProperty.js\"));\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  \"default\": function _default() {\n    return Router;\n  },\n  matchesMiddleware: function matchesMiddleware() {\n    return _matchesMiddleware;\n  },\n  createKey: function createKey() {\n    return _createKey;\n  }\n});\n\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\n\nvar _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\n\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\n\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\n\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\n\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\n\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\n\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\n\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\n\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\n\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\n\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\n\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\n\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\n\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\n\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\n\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\n\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\n\nfunction _matchesMiddleware(_x) {\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction _matchesMiddleware2() {\n  _matchesMiddleware2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(options) {\n    var matchers, _ref6, asPathname, cleanedAs, asWithBasePathAndLocale;\n\n    return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.next = 2;\n          return Promise.resolve(options.router.pageLoader.getMiddleware());\n\n        case 2:\n          matchers = _context8.sent;\n\n          if (matchers) {\n            _context8.next = 5;\n            break;\n          }\n\n          return _context8.abrupt(\"return\", false);\n\n        case 5:\n          _ref6 = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref6.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n\n          cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n          asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n          // where we can access more info such as headers, HttpOnly cookie, etc.\n\n          return _context8.abrupt(\"return\", matchers.some(function (m) {\n            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n          }));\n\n        case 9:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _ref = (0, _resolvehref.resolveHref)(router, url, true),\n      _ref2 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n      resolvedHref = _ref2[0],\n      resolvedAs = _ref2[1];\n\n  var origin = (0, _utils.getLocationOrigin)();\n  var hrefWasAbsolute = resolvedHref.startsWith(origin);\n  var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  var matchedPath = response.headers.get(\"x-matched-path\");\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || undefined) {\n      var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(function (param) {\n        var _param = (0, _slicedToArray2[\"default\"])(param, 2),\n            pages = _param[0],\n            rewrites = _param[1].__rewrites;\n\n        var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            nextConfig:  false ? 0 : nextConfig,\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (false) { var result; } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsepath.parsePath)(source);\n    var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    })), {}, {\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    }));\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n\n  var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      var _src = (0, _parsepath.parsePath)(redirectTarget);\n\n      var _pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      })), {}, {\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      }));\n\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + _pathname + _src.query + _src.hash,\n        newUrl: \"\" + _pathname + _src.query + _src.hash\n      });\n    }\n\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\n\nfunction withMiddlewareEffects(_x2) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee9(options) {\n    var matches, data, effect;\n    return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          _context9.next = 2;\n          return _matchesMiddleware(options);\n\n        case 2:\n          matches = _context9.sent;\n\n          if (!(!matches || !options.fetchData)) {\n            _context9.next = 5;\n            break;\n          }\n\n          return _context9.abrupt(\"return\", null);\n\n        case 5:\n          _context9.prev = 5;\n          _context9.next = 8;\n          return options.fetchData();\n\n        case 8:\n          data = _context9.sent;\n          _context9.next = 11;\n          return getMiddlewareData(data.dataHref, data.response, options);\n\n        case 11:\n          effect = _context9.sent;\n          return _context9.abrupt(\"return\", {\n            dataHref: data.dataHref,\n            json: data.json,\n            response: data.response,\n            text: data.text,\n            cacheKey: data.cacheKey,\n            effect: effect\n          });\n\n        case 15:\n          _context9.prev = 15;\n          _context9.t0 = _context9[\"catch\"](5);\n          return _context9.abrupt(\"return\", null);\n\n        case 18:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9, null, [[5, 15]]);\n  }));\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction fetchNextData(param) {\n  var dataHref = param.dataHref,\n      inflightCache = param.inflightCache,\n      isPrefetch = param.isPrefetch,\n      hasMiddleware = param.hasMiddleware,\n      isServerRender = param.isServerRender,\n      parseJSON = param.parseJSON,\n      persistCache = param.persistCache,\n      isBackground = param.isBackground,\n      unstable_skipClientCache = param.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var _params_method;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: \"prefetch\"\n      } : {}, isPrefetch && hasMiddleware ? {\n        \"x-middleware-prefetch\": \"1\"\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: \"\",\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    })[\"catch\"](function (err) {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n\n      if ( // chrome\n      err.message === \"Failed to fetch\" || // firefox\n      err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n      err.message === \"Load failed\") {\n        (0, _routeloader.markAssetError)(err);\n      }\n\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\n\nfunction _createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(param) {\n  var url = param.url,\n      router = param.router; // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(param) {\n  var route = param.route,\n      router = param.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref3) {\n    var _this = this;\n\n    var initialProps = _ref3.initialProps,\n        pageLoader = _ref3.pageLoader,\n        App = _ref3.App,\n        wrapApp = _ref3.wrapApp,\n        Component = _ref3.Component,\n        err = _ref3.err,\n        subscription = _ref3.subscription,\n        isFallback = _ref3.isFallback,\n        locale = _ref3.locale,\n        locales = _ref3.locales,\n        defaultLocale = _ref3.defaultLocale,\n        domainLocales = _ref3.domainLocales,\n        isPreview = _ref3.isPreview;\n    (0, _classCallCheck2[\"default\"])(this, Router);\n    // Server Data Cache (full data requests)\n    this.sdc = {}; // Server Background Cache (HEAD requests)\n\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = _createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n      _this.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this.pathname,\n            _query = _this.query;\n\n        _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(_pathname2),\n          query: _query\n        }), (0, _utils.getURL)());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (false) { var v; }\n\n      _this._key = key;\n\n      var _ref4 = (0, _parserelativeurl.parseRelativeUrl)(url),\n          pathname = _ref4.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this.isSsr && as === (0, _addbasepath.addBasePath)(_this.asPath) && pathname === (0, _addbasepath.addBasePath)(_this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this._bps && !_this._bps(state)) {\n        return;\n      }\n\n      _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this._shallow,\n        locale: options.locale || _this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removetrailingslash.removeTrailingSlash)(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n\n    if (true) {\n      var _require2 = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\"),\n          BloomFilter = _require2.BloomFilter;\n\n      var staticFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n      var dynamicFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n\n      if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n\n        this._bfl_s[\"import\"](staticFilterData);\n      }\n\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n\n        this._bfl_d[\"import\"](dynamicFilterData);\n      }\n    } // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath =  false || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n\n    if (false) {}\n\n    this.state = {\n      route: route,\n      pathname: pathname,\n      query: query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = _matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as !== pathname;\n\n          _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query: query\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener(\"popstate\", this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  (0, _createClass2[\"default\"])(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Go forward in history\n    */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      window.history.forward();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as, options) {\n      if (options === void 0) options = {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change(\"pushState\", url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as, options) {\n      if (options === void 0) options = {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change(\"replaceState\", url, as, options);\n    }\n  }, {\n    key: \"_bfl\",\n    value: function () {\n      var _bfl2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(as, resolvedAs, locale, skipNavigate) {\n        var matchesBflStatic, matchesBflDynamic, _i, _arr, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i2, _arr2, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (false) {}\n\n              matchesBflStatic = false;\n              matchesBflDynamic = false;\n              _i = 0, _arr = [as, resolvedAs];\n\n            case 4:\n              if (!(_i < _arr.length)) {\n                _context.next = 35;\n                break;\n              }\n\n              curAs = _arr[_i];\n\n              if (!curAs) {\n                _context.next = 32;\n                break;\n              }\n\n              asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n              asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n\n              if (!(asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname))) {\n                _context.next = 32;\n                break;\n              }\n\n              matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n              _i2 = 0, _arr2 = [asNoSlash, asNoSlashLocale];\n\n            case 12:\n              if (!(_i2 < _arr2.length)) {\n                _context.next = 27;\n                break;\n              }\n\n              normalizedAS = _arr2[_i2];\n              // if any sub-path of as matches a dynamic filter path\n              // it should be hard navigated\n              curAsParts = normalizedAS.split(\"/\");\n              i = 0;\n\n            case 16:\n              if (!(!matchesBflDynamic && i < curAsParts.length + 1)) {\n                _context.next = 24;\n                break;\n              }\n\n              currentPart = curAsParts.slice(0, i).join(\"/\");\n\n              if (!(currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart)))) {\n                _context.next = 21;\n                break;\n              }\n\n              matchesBflDynamic = true;\n              return _context.abrupt(\"break\", 24);\n\n            case 21:\n              i++;\n              _context.next = 16;\n              break;\n\n            case 24:\n              _i2++;\n              _context.next = 12;\n              break;\n\n            case 27:\n              if (!(matchesBflStatic || matchesBflDynamic)) {\n                _context.next = 32;\n                break;\n              }\n\n              if (!skipNavigate) {\n                _context.next = 30;\n                break;\n              }\n\n              return _context.abrupt(\"return\", true);\n\n            case 30:\n              handleHardNavigation({\n                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                router: this\n              });\n              return _context.abrupt(\"return\", new Promise(function () {}));\n\n            case 32:\n              _i++;\n              _context.next = 4;\n              break;\n\n            case 35:\n              return _context.abrupt(\"return\", false);\n\n            case 36:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n\n      function _bfl(_x3, _x4, _x5, _x6) {\n        return _bfl2.apply(this, arguments);\n      }\n\n      return _bfl;\n    }()\n  }, {\n    key: \"change\",\n    value: function () {\n      var _change = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(method, url, as, options, forcedScroll) {\n        var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, rewritesResult, routeMatch, _parsedAs, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs4, newUrl, newAs, notFoundRoute, _routeInfo_route, isValidShallowRoute, _options_scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, canSkipUpdating, hashRegex;\n\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if ((0, _islocalurl.isLocalURL)(url)) {\n                _context2.next = 3;\n                break;\n              }\n\n              handleHardNavigation({\n                url: url,\n                router: this\n              });\n              return _context2.abrupt(\"return\", false);\n\n            case 3:\n              // WARNING: `_h` is an internal option for handing Next.js client-side\n              // hydration. Your app should _never_ use this property. It may change at\n              // any time without notice.\n              isQueryUpdating = options._h === 1;\n\n              if (!(!isQueryUpdating && !options.shallow)) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 7;\n              return this._bfl(as, undefined, options.locale);\n\n            case 7:\n              shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n              nextState = _objectSpread({}, this.state); // for static pages with query params in the URL we delay\n              // marking the router ready until after the query is updated\n              // or a navigation has occurred\n\n              readyStateChange = this.isReady !== true;\n              this.isReady = true;\n              isSsr = this.isSsr;\n\n              if (!isQueryUpdating) {\n                this.isSsr = false;\n              } // if a route transition is already in progress before\n              // the query updating is triggered ignore query updating\n\n\n              if (!(isQueryUpdating && this.clc)) {\n                _context2.next = 15;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", false);\n\n            case 15:\n              prevLocale = nextState.locale;\n\n              if (true) {\n                _context2.next = 28;\n                break;\n              }\n\n              nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n              if (typeof options.locale === \"undefined\") {\n                options.locale = nextState.locale;\n              }\n\n              parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n              localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n\n              if (localePathResult.detectedLocale) {\n                nextState.locale = localePathResult.detectedLocale;\n                parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                as = (0, _formaturl.formatWithValidation)(parsedAs);\n                url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n              }\n\n              didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n              // moves this on its own due to the return\n\n              if (false) {}\n\n              detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n              // moves this on its own due to the return\n\n              if (false) {}\n\n              if (!didNavigate) {\n                _context2.next = 28;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 28:\n              // marking route changes as a navigation start entry\n              if (_utils.ST) {\n                performance.mark(\"routeChange\");\n              }\n\n              _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n              routeProps = {\n                shallow: shallow\n              };\n\n              if (this._inFlightRoute && this.clc) {\n                if (!isSsr) {\n                  Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n                }\n\n                this.clc();\n                this.clc = null;\n              }\n\n              as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n              cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n              this._inFlightRoute = as;\n              localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n              // We should not proceed. We should only change the state.\n\n              if (!(!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                _context2.next = 52;\n                break;\n              }\n\n              nextState.asPath = cleanedAs;\n              Router.events.emit(\"hashChangeStart\", as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n              this.changeState(method, url, as, _objectSpread(_objectSpread({}, options), {}, {\n                scroll: false\n              }));\n\n              if (scroll) {\n                this.scrollToHash(cleanedAs);\n              }\n\n              _context2.prev = 41;\n              _context2.next = 44;\n              return this.set(nextState, this.components[nextState.route], null);\n\n            case 44:\n              _context2.next = 50;\n              break;\n\n            case 46:\n              _context2.prev = 46;\n              _context2.t0 = _context2[\"catch\"](41);\n\n              if ((0, _iserror[\"default\"])(_context2.t0) && _context2.t0.cancelled) {\n                Router.events.emit(\"routeChangeError\", _context2.t0, cleanedAs, routeProps);\n              }\n\n              throw _context2.t0;\n\n            case 50:\n              Router.events.emit(\"hashChangeComplete\", as, routeProps);\n              return _context2.abrupt(\"return\", true);\n\n            case 52:\n              parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n              pathname = parsed.pathname, query = parsed.query; // if we detected the path as app route during prefetching\n              // trigger hard navigation\n\n              if (!((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter)) {\n                _context2.next = 57;\n                break;\n              }\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 57:\n              _context2.prev = 57;\n              _context2.next = 60;\n              return Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n\n            case 60:\n              _yield$Promise$all = _context2.sent;\n              _yield$Promise$all2 = (0, _slicedToArray2[\"default\"])(_yield$Promise$all, 2);\n              pages = _yield$Promise$all2[0];\n              rewrites = _yield$Promise$all2[1].__rewrites;\n              _context2.next = 70;\n              break;\n\n            case 66:\n              _context2.prev = 66;\n              _context2.t1 = _context2[\"catch\"](57);\n              // If we fail to resolve the page list or client-build manifest, we must\n              // do a server-side transition:\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", false);\n\n            case 70:\n              // If asked to change the current URL we should reload the current page\n              // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n              // We also need to set the method = replaceState always\n              // as this should not go into the history (That's how browsers work)\n              // We should compare the new asPath to the current asPath, not the url\n              if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                method = \"replaceState\";\n              } // we need to resolve the as value using rewrites for dynamic SSG\n              // pages to allow building the data URL correctly\n\n\n              resolvedAs = as; // url and as should always be prefixed with basePath by this\n              // point by either next/link or router.push/replace so strip the\n              // basePath from the pathname to match the pages dir 1-to-1\n\n              pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n              route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n              parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n              isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname))); // we don't attempt resolve asPath when we need to execute\n              // middleware as the resolving will occur server-side\n\n              _context2.t2 = !options.shallow;\n\n              if (!_context2.t2) {\n                _context2.next = 81;\n                break;\n              }\n\n              _context2.next = 80;\n              return _matchesMiddleware({\n                asPath: as,\n                locale: nextState.locale,\n                router: this\n              });\n\n            case 80:\n              _context2.t2 = _context2.sent;\n\n            case 81:\n              isMiddlewareMatch = _context2.t2;\n\n              if (isQueryUpdating && isMiddlewareMatch) {\n                shouldResolveHref = false;\n              }\n\n              if (!(shouldResolveHref && pathname !== \"/_error\")) {\n                _context2.next = 96;\n                break;\n              }\n\n              options._shouldResolveHref = true;\n\n              if (true) {\n                _context2.next = 94;\n                break;\n              }\n\n              rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                return resolveDynamicRoute(p, pages);\n              }, this.locales);\n\n              if (!rewritesResult.externalDest) {\n                _context2.next = 90;\n                break;\n              }\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", true);\n\n            case 90:\n              if (!isMiddlewareMatch) {\n                resolvedAs = rewritesResult.asPath;\n              }\n\n              if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n              _context2.next = 96;\n              break;\n\n            case 94:\n              parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n              if (parsed.pathname !== pathname) {\n                pathname = parsed.pathname;\n                parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n            case 96:\n              if ((0, _islocalurl.isLocalURL)(as)) {\n                _context2.next = 101;\n                break;\n              }\n\n              if (false) {}\n\n              throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n            case 99:\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", false);\n\n            case 101:\n              resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n              route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n              routeMatch = false;\n\n              if (!(0, _isdynamic.isDynamicRoute)(route)) {\n                _context2.next = 119;\n                break;\n              }\n\n              _parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n              asPathname = _parsedAs.pathname;\n              routeRegex = (0, _routeregex.getRouteRegex)(route);\n              routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n              shouldInterpolate = route === asPathname;\n              interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n\n              if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                _context2.next = 118;\n                break;\n              }\n\n              missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                return !query[param] && !routeRegex.groups[param].optional;\n              });\n\n              if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                _context2.next = 116;\n                break;\n              }\n\n              if (true) {\n                console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n              }\n\n              throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n\n            case 116:\n              _context2.next = 119;\n              break;\n\n            case 118:\n              if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, _parsedAs, {\n                  pathname: interpolatedAs.result,\n                  query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n              } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n              }\n\n            case 119:\n              if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeStart\", as, routeProps);\n              }\n\n              isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n              _context2.prev = 121;\n              _context2.next = 124;\n              return this.getRouteInfo({\n                route: route,\n                pathname: pathname,\n                query: query,\n                as: as,\n                resolvedAs: resolvedAs,\n                routeProps: routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite: isMiddlewareRewrite\n              });\n\n            case 124:\n              routeInfo = _context2.sent;\n\n              if (!(!isQueryUpdating && !options.shallow)) {\n                _context2.next = 128;\n                break;\n              }\n\n              _context2.next = 128;\n              return this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n\n            case 128:\n              if (\"route\" in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n\n                if (!routeProps.shallow) {\n                  query = Object.assign({}, routeInfo.query || {}, query);\n                }\n\n                cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                  Object.keys(routeMatch).forEach(function (key) {\n                    if (routeMatch && query[key] === routeMatch[key]) {\n                      delete query[key];\n                    }\n                  });\n                }\n\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                  prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                  rewriteAs = prefixedAs;\n\n                  if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                    rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                  }\n\n                  if (false) {}\n\n                  _routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                  curRouteMatch = (0, _routematcher.getRouteMatcher)(_routeRegex)(new URL(rewriteAs, location.href).pathname);\n\n                  if (curRouteMatch) {\n                    Object.assign(query, curRouteMatch);\n                  }\n                }\n              } // If the routeInfo brings a redirect we simply apply it.\n\n\n              if (!(\"type\" in routeInfo)) {\n                _context2.next = 136;\n                break;\n              }\n\n              if (!(routeInfo.type === \"redirect-internal\")) {\n                _context2.next = 134;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n            case 134:\n              handleHardNavigation({\n                url: routeInfo.destination,\n                router: this\n              });\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 136:\n              component = routeInfo.Component;\n\n              if (component && component.unstable_scriptLoader) {\n                scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach(function (script) {\n                  (0, _script.handleClientScriptLoad)(script.props);\n                });\n              } // handle redirect on client-transition\n\n\n              if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) {\n                _context2.next = 165;\n                break;\n              }\n\n              if (!(routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT)) {\n                _context2.next = 149;\n                break;\n              }\n\n              // Use the destination from redirect without adding locale\n              options.locale = false;\n              destination = routeInfo.props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n              // client-navigation if it is falling back to hard navigation if\n              // it's not\n\n              if (!(destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                _context2.next = 147;\n                break;\n              }\n\n              parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n              parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n              _prepareUrlAs4 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs4.url, newAs = _prepareUrlAs4.as;\n              return _context2.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n\n            case 147:\n              handleHardNavigation({\n                url: destination,\n                router: this\n              });\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 149:\n              nextState.isPreview = !!routeInfo.props.__N_PREVIEW; // handle SSG data 404\n\n              if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) {\n                _context2.next = 165;\n                break;\n              }\n\n              _context2.prev = 151;\n              _context2.next = 154;\n              return this.fetchComponent(\"/404\");\n\n            case 154:\n              notFoundRoute = \"/404\";\n              _context2.next = 160;\n              break;\n\n            case 157:\n              _context2.prev = 157;\n              _context2.t3 = _context2[\"catch\"](151);\n              notFoundRoute = \"/_error\";\n\n            case 160:\n              _context2.next = 162;\n              return this.getRouteInfo({\n                route: notFoundRoute,\n                pathname: notFoundRoute,\n                query: query,\n                as: as,\n                resolvedAs: resolvedAs,\n                routeProps: {\n                  shallow: false\n                },\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                isNotFound: true\n              });\n\n            case 162:\n              routeInfo = _context2.sent;\n\n              if (!(\"type\" in routeInfo)) {\n                _context2.next = 165;\n                break;\n              }\n\n              throw new Error(\"Unexpected middleware effect on /404\");\n\n            case 165:\n              if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n              }\n\n              // shallow routing is only allowed for same page URL changes.\n              isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n              shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n              resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n              } : null;\n              upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // the new state that the router gonna set\n\n              upcomingRouterState = _objectSpread(_objectSpread({}, nextState), {}, {\n                route: route,\n                pathname: pathname,\n                query: query,\n                asPath: cleanedAs,\n                isFallback: false\n              }); // When the page being rendered is the 404 page, we should only update the\n              // query parameters. Route changes here might add the basePath when it\n              // wasn't originally present. This is also why this block is before the\n              // below `changeState` call which updates the browser's history (changing\n              // the URL).\n\n              if (!(isQueryUpdating && isErrorRoute)) {\n                _context2.next = 188;\n                break;\n              }\n\n              _context2.next = 174;\n              return this.getRouteInfo({\n                route: this.pathname,\n                pathname: this.pathname,\n                query: query,\n                as: as,\n                resolvedAs: resolvedAs,\n                routeProps: {\n                  shallow: false\n                },\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                isQueryUpdating: isQueryUpdating && !this.isFallback\n              });\n\n            case 174:\n              routeInfo = _context2.sent;\n\n              if (!(\"type\" in routeInfo)) {\n                _context2.next = 177;\n                break;\n              }\n\n              throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n\n            case 177:\n              if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n              }\n\n              _context2.prev = 178;\n              _context2.next = 181;\n              return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n            case 181:\n              _context2.next = 187;\n              break;\n\n            case 183:\n              _context2.prev = 183;\n              _context2.t4 = _context2[\"catch\"](178);\n\n              if ((0, _iserror[\"default\"])(_context2.t4) && _context2.t4.cancelled) {\n                Router.events.emit(\"routeChangeError\", _context2.t4, cleanedAs, routeProps);\n              }\n\n              throw _context2.t4;\n\n            case 187:\n              return _context2.abrupt(\"return\", true);\n\n            case 188:\n              Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n              this.changeState(method, url, as, options); // for query updates we can skip it if the state is unchanged and we don't\n              // need to scroll\n              // https://github.com/vercel/next.js/issues/37139\n\n              canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n\n              if (canSkipUpdating) {\n                _context2.next = 211;\n                break;\n              }\n\n              _context2.prev = 192;\n              _context2.next = 195;\n              return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n            case 195:\n              _context2.next = 204;\n              break;\n\n            case 197:\n              _context2.prev = 197;\n              _context2.t5 = _context2[\"catch\"](192);\n\n              if (!_context2.t5.cancelled) {\n                _context2.next = 203;\n                break;\n              }\n\n              routeInfo.error = routeInfo.error || _context2.t5;\n              _context2.next = 204;\n              break;\n\n            case 203:\n              throw _context2.t5;\n\n            case 204:\n              if (!routeInfo.error) {\n                _context2.next = 207;\n                break;\n              }\n\n              if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n              }\n\n              throw routeInfo.error;\n\n            case 207:\n              if (false) {}\n\n              if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeComplete\", as, routeProps);\n              } // A hash mark # is the optional last part of a URL\n\n\n              hashRegex = /#.+$/;\n\n              if (shouldScroll && hashRegex.test(as)) {\n                this.scrollToHash(as);\n              }\n\n            case 211:\n              return _context2.abrupt(\"return\", true);\n\n            case 214:\n              _context2.prev = 214;\n              _context2.t6 = _context2[\"catch\"](121);\n\n              if (!((0, _iserror[\"default\"])(_context2.t6) && _context2.t6.cancelled)) {\n                _context2.next = 218;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", false);\n\n            case 218:\n              throw _context2.t6;\n\n            case 219:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[41, 46], [57, 66], [121, 214], [151, 157], [178, 183], [192, 197]]);\n      }));\n\n      function change(_x7, _x8, _x9, _x10, _x11) {\n        return _change.apply(this, arguments);\n      }\n\n      return change;\n    }()\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as, options) {\n      if (options === void 0) options = {};\n\n      if (true) {\n        if (typeof window.history === \"undefined\") {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === \"undefined\") {\n          console.error(\"Warning: window.history.\" + method + \" is not available\");\n          return;\n        }\n      }\n\n      if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== \"pushState\" ? this._key : _createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        \"\", as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function () {\n      var _handleRouteInfoError = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(err, pathname, query, as, routeProps, loadErrorFail) {\n        var props, _yield$this$fetchComp2, Component, styleSheets, routeInfo;\n\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              console.error(err);\n\n              if (!err.cancelled) {\n                _context3.next = 3;\n                break;\n              }\n\n              throw err;\n\n            case 3:\n              if (!((0, _routeloader.isAssetError)(err) || loadErrorFail)) {\n                _context3.next = 7;\n                break;\n              }\n\n              Router.events.emit(\"routeChangeError\", err, as, routeProps); // If we can't load the page it could be one of following reasons\n              //  1. Page doesn't exists\n              //  2. Page does exist in a different zone\n              //  3. Internal error while loading the page\n              // So, doing a hard reload is the proper way to deal with this.\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              }); // Changing the URL doesn't block executing the current code path.\n              // So let's throw a cancellation error stop the routing logic.\n\n              throw buildCancellationError();\n\n            case 7:\n              _context3.prev = 7;\n              _context3.next = 10;\n              return this.fetchComponent(\"/_error\");\n\n            case 10:\n              _yield$this$fetchComp2 = _context3.sent;\n              Component = _yield$this$fetchComp2.page;\n              styleSheets = _yield$this$fetchComp2.styleSheets;\n              routeInfo = {\n                props: props,\n                Component: Component,\n                styleSheets: styleSheets,\n                err: err,\n                error: err\n              };\n\n              if (routeInfo.props) {\n                _context3.next = 25;\n                break;\n              }\n\n              _context3.prev = 15;\n              _context3.next = 18;\n              return this.getInitialProps(Component, {\n                err: err,\n                pathname: pathname,\n                query: query\n              });\n\n            case 18:\n              routeInfo.props = _context3.sent;\n              _context3.next = 25;\n              break;\n\n            case 21:\n              _context3.prev = 21;\n              _context3.t0 = _context3[\"catch\"](15);\n              console.error(\"Error in error page `getInitialProps`: \", _context3.t0);\n              routeInfo.props = {};\n\n            case 25:\n              return _context3.abrupt(\"return\", routeInfo);\n\n            case 28:\n              _context3.prev = 28;\n              _context3.t1 = _context3[\"catch\"](7);\n              return _context3.abrupt(\"return\", this.handleRouteInfoError((0, _iserror[\"default\"])(_context3.t1) ? _context3.t1 : new Error(_context3.t1 + \"\"), pathname, query, as, routeProps, true));\n\n            case 31:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[7, 28], [15, 21]]);\n      }));\n\n      function handleRouteInfoError(_x12, _x13, _x14, _x15, _x16, _x17) {\n        return _handleRouteInfoError.apply(this, arguments);\n      }\n\n      return handleRouteInfoError;\n    }()\n  }, {\n    key: \"getRouteInfo\",\n    value: function () {\n      var _getRouteInfo = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(param) {\n        var _this2 = this;\n\n        var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, resolvedRoute, pages, routeInfo, _require4, isValidElementType, wasBailedPrefetch, shouldFetchData, _yield$this$_getData2, props, cacheKey;\n\n        return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n              /**\n              * This `route` binding can change if there's a rewrite\n              * so we keep a reference to the original requested route\n              * so we can store the cache for it and avoid re-requesting every time\n              * for shallow routing purposes.\n              */\n\n              route = requestedRoute;\n              _context5.prev = 2;\n              handleCancelled = getCancelledHandler({\n                route: route,\n                router: this\n              });\n              existingInfo = this.components[route];\n\n              if (!(routeProps.shallow && existingInfo && this.route === route)) {\n                _context5.next = 7;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", existingInfo);\n\n            case 7:\n              if (hasMiddleware) {\n                existingInfo = undefined;\n              }\n\n              cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && false ? 0 : undefined;\n              isBackground = isQueryUpdating;\n              fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                  href: (0, _formaturl.formatWithValidation)({\n                    pathname: pathname,\n                    query: query\n                  }),\n                  skipInterpolation: true,\n                  asPath: isNotFound ? \"/404\" : resolvedAs,\n                  locale: locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache: unstable_skipClientCache,\n                isBackground: isBackground\n              };\n\n              if (!(isQueryUpdating && !isMiddlewareRewrite)) {\n                _context5.next = 15;\n                break;\n              }\n\n              _context5.t0 = null;\n              _context5.next = 18;\n              break;\n\n            case 15:\n              _context5.next = 17;\n              return withMiddlewareEffects({\n                fetchData: function fetchData() {\n                  return fetchNextData(fetchNextDataParams);\n                },\n                asPath: isNotFound ? \"/404\" : resolvedAs,\n                locale: locale,\n                router: this\n              })[\"catch\"](function (err) {\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                  return null;\n                }\n\n                throw err;\n              });\n\n            case 17:\n              _context5.t0 = _context5.sent;\n\n            case 18:\n              data = _context5.t0;\n\n              // when rendering error routes we don't apply middleware\n              // effects\n              if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                data.effect = undefined;\n              }\n\n              if (isQueryUpdating) {\n                if (!data) {\n                  data = {\n                    json: self.__NEXT_DATA__.props\n                  };\n                } else {\n                  data.json = self.__NEXT_DATA__.props;\n                }\n              }\n\n              handleCancelled();\n\n              if (!((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\")) {\n                _context5.next = 24;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", data.effect);\n\n            case 24:\n              if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) {\n                _context5.next = 37;\n                break;\n              }\n\n              resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n              _context5.next = 28;\n              return this.pageLoader.getPageList();\n\n            case 28:\n              pages = _context5.sent;\n\n              if (!(!isQueryUpdating || pages.includes(resolvedRoute))) {\n                _context5.next = 37;\n                break;\n              }\n\n              route = resolvedRoute;\n              pathname = data.effect.resolvedHref;\n              query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n              resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname); // Check again the cache with the new destination.\n\n              existingInfo = this.components[route];\n\n              if (!(routeProps.shallow && existingInfo && this.route === route && !hasMiddleware)) {\n                _context5.next = 37;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", _objectSpread(_objectSpread({}, existingInfo), {}, {\n                route: route\n              }));\n\n            case 37:\n              if (!(0, _isapiroute.isAPIRoute)(route)) {\n                _context5.next = 40;\n                break;\n              }\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context5.abrupt(\"return\", new Promise(function () {}));\n\n            case 40:\n              _context5.t1 = cachedRouteInfo;\n\n              if (_context5.t1) {\n                _context5.next = 45;\n                break;\n              }\n\n              _context5.next = 44;\n              return this.fetchComponent(route).then(function (res) {\n                return {\n                  Component: res.page,\n                  styleSheets: res.styleSheets,\n                  __N_SSG: res.mod.__N_SSG,\n                  __N_SSP: res.mod.__N_SSP\n                };\n              });\n\n            case 44:\n              _context5.t1 = _context5.sent;\n\n            case 45:\n              routeInfo = _context5.t1;\n\n              if (false) {}\n\n              _require4 = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\"), isValidElementType = _require4.isValidElementType;\n\n              if (isValidElementType(routeInfo.Component)) {\n                _context5.next = 50;\n                break;\n              }\n\n              throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n\n            case 50:\n              wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n              shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP; // For non-SSG prefetches that bailed before sending data\n              // we clear the cache to fetch full response\n\n              if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                delete this.sdc[data.dataHref];\n              }\n\n              _context5.next = 55;\n              return this._getData( /*#__PURE__*/(0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4() {\n                var dataHref, fetched;\n                return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      if (!shouldFetchData) {\n                        _context4.next = 8;\n                        break;\n                      }\n\n                      if (!((data == null ? void 0 : data.json) && !wasBailedPrefetch)) {\n                        _context4.next = 3;\n                        break;\n                      }\n\n                      return _context4.abrupt(\"return\", {\n                        cacheKey: data.cacheKey,\n                        props: data.json\n                      });\n\n                    case 3:\n                      dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this2.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                          pathname: pathname,\n                          query: query\n                        }),\n                        asPath: resolvedAs,\n                        locale: locale\n                      });\n                      _context4.next = 6;\n                      return fetchNextData({\n                        dataHref: dataHref,\n                        isServerRender: _this2.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : _this2.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache: unstable_skipClientCache\n                      });\n\n                    case 6:\n                      fetched = _context4.sent;\n                      return _context4.abrupt(\"return\", {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                      });\n\n                    case 8:\n                      _context4.t0 = {};\n                      _context4.next = 11;\n                      return _this2.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                      {\n                        pathname: pathname,\n                        query: query,\n                        asPath: as,\n                        locale: locale,\n                        locales: _this2.locales,\n                        defaultLocale: _this2.defaultLocale\n                      });\n\n                    case 11:\n                      _context4.t1 = _context4.sent;\n                      return _context4.abrupt(\"return\", {\n                        headers: _context4.t0,\n                        props: _context4.t1\n                      });\n\n                    case 13:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4);\n              })));\n\n            case 55:\n              _yield$this$_getData2 = _context5.sent;\n              props = _yield$this$_getData2.props;\n              cacheKey = _yield$this$_getData2.cacheKey;\n\n              // Only bust the data cache for SSP routes although\n              // middleware can skip cache per request with\n              // x-middleware-cache: no-cache as well\n              if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n              } // we kick off a HEAD request in the background\n              // when a non-prefetch request is made to signal revalidation\n\n\n              if (!this.isPreview && routeInfo.__N_SSG && false && 0) {}\n\n              props.pageProps = Object.assign({}, props.pageProps);\n              routeInfo.props = props;\n              routeInfo.route = route;\n              routeInfo.query = query;\n              routeInfo.resolvedAs = resolvedAs;\n              this.components[route] = routeInfo;\n              return _context5.abrupt(\"return\", routeInfo);\n\n            case 69:\n              _context5.prev = 69;\n              _context5.t2 = _context5[\"catch\"](2);\n              return _context5.abrupt(\"return\", this.handleRouteInfoError((0, _iserror.getProperError)(_context5.t2), pathname, query, as, routeProps));\n\n            case 72:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[2, 69]]);\n      }));\n\n      function getRouteInfo(_x18) {\n        return _getRouteInfo.apply(this, arguments);\n      }\n\n      return getRouteInfo;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split(\"#\"),\n          _this$asPath$split2 = (0, _slicedToArray2[\"default\"])(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split(\"#\"),\n          _as$split2 = (0, _slicedToArray2[\"default\"])(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split(\"#\"),\n          _as$split4 = (0, _slicedToArray2[\"default\"])(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? \"\" : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === \"\" || hash === \"top\") {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function () {\n      var _prefetch = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6(url, asPath, options) {\n        var _this3 = this;\n\n        var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield, rewritesResult, data, route;\n\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (asPath === void 0) asPath = url;\n              if (options === void 0) options = {}; // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n              if (false) {}\n\n              return _context6.abrupt(\"return\");\n\n            case 4:\n              if (!( true && (0, _isbot.isBot)(window.navigator.userAgent))) {\n                _context6.next = 6;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 6:\n              parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n              urlPathname = parsed.pathname;\n              pathname = parsed.pathname, query = parsed.query;\n              originalPathname = pathname;\n\n              if (false) {}\n\n              _context6.next = 13;\n              return this.pageLoader.getPageList();\n\n            case 13:\n              pages = _context6.sent;\n              resolvedAs = asPath;\n              locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n              _context6.next = 18;\n              return _matchesMiddleware({\n                asPath: asPath,\n                locale: locale,\n                router: this\n              });\n\n            case 18:\n              isMiddlewareMatch = _context6.sent;\n\n              if (true) {\n                _context6.next = 29;\n                break;\n              }\n\n              _context6.next = 22;\n              return (0, _routeloader.getClientBuildManifest)();\n\n            case 22:\n              _yield = _context6.sent;\n              rewrites = _yield.__rewrites;\n              rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, function (p) {\n                return resolveDynamicRoute(p, pages);\n              }, this.locales);\n\n              if (!rewritesResult.externalDest) {\n                _context6.next = 27;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 27:\n              if (!isMiddlewareMatch) {\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n              }\n\n              if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n            case 29:\n              parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n              if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n              if (true) {\n                _context6.next = 35;\n                break;\n              }\n\n              _context6.t0 = null;\n              _context6.next = 38;\n              break;\n\n            case 35:\n              _context6.next = 37;\n              return withMiddlewareEffects({\n                fetchData: function fetchData() {\n                  return fetchNextData({\n                    dataHref: _this3.pageLoader.getDataHref({\n                      href: (0, _formaturl.formatWithValidation)({\n                        pathname: originalPathname,\n                        query: query\n                      }),\n                      skipInterpolation: true,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: _this3.isSsr,\n                    parseJSON: true,\n                    inflightCache: _this3.sdc,\n                    persistCache: !_this3.isPreview,\n                    isPrefetch: true\n                  });\n                },\n                asPath: asPath,\n                locale: locale,\n                router: this\n              });\n\n            case 37:\n              _context6.t0 = _context6.sent;\n\n            case 38:\n              data = _context6.t0;\n\n              /**\n              * If there was a rewrite we apply the effects of the rewrite on the\n              * current parameters for the prefetch.\n              */\n              if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                parsed.pathname = data.effect.resolvedHref;\n                pathname = data.effect.resolvedHref;\n                query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                resolvedAs = data.effect.parsedAs.pathname;\n                url = (0, _formaturl.formatWithValidation)(parsed);\n              }\n              /**\n              * If there is a redirect to an external destination then we don't have\n              * to prefetch content as it will be unused.\n              */\n\n\n              if (!((data == null ? void 0 : data.effect.type) === \"redirect-external\")) {\n                _context6.next = 42;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 42:\n              route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n              _context6.next = 45;\n              return this._bfl(asPath, resolvedAs, options.locale, true);\n\n            case 45:\n              if (!_context6.sent) {\n                _context6.next = 47;\n                break;\n              }\n\n              this.components[urlPathname] = {\n                __appRouter: true\n              };\n\n            case 47:\n              _context6.next = 49;\n              return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {\n                return isSsg ? fetchNextData({\n                  dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this3.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    locale: locale\n                  }),\n                  isServerRender: false,\n                  parseJSON: true,\n                  inflightCache: _this3.sdc,\n                  persistCache: !_this3.isPreview,\n                  isPrefetch: true,\n                  unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(function () {\n                  return false;\n                })[\"catch\"](function () {\n                  return false;\n                }) : false;\n              }), this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n\n            case 49:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n\n      function prefetch(_x19, _x20, _x21) {\n        return _prefetch.apply(this, arguments);\n      }\n\n      return prefetch;\n    }()\n  }, {\n    key: \"fetchComponent\",\n    value: function () {\n      var _fetchComponent = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7(route) {\n        var handleCancelled, componentResult;\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              handleCancelled = getCancelledHandler({\n                route: route,\n                router: this\n              });\n              _context7.prev = 1;\n              _context7.next = 4;\n              return this.pageLoader.loadPage(route);\n\n            case 4:\n              componentResult = _context7.sent;\n              handleCancelled();\n              return _context7.abrupt(\"return\", componentResult);\n\n            case 9:\n              _context7.prev = 9;\n              _context7.t0 = _context7[\"catch\"](1);\n              handleCancelled();\n              throw _context7.t0;\n\n            case 13:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[1, 9]]);\n      }));\n\n      function fetchComponent(_x22) {\n        return _fetchComponent.apply(this, arguments);\n      }\n\n      return fetchComponent;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this4 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this4.clc) {\n          _this4.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error(\"Loading initial props cancelled\");\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (param) {\n        var text = param.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components[\"/_app\"].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils.loadGetInitialProps)(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n  return Router;\n}();\n\n(function () {\n  Router.events = (0, _mitt[\"default\"])();\n})();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBLE1BQU1DLENBQU47O0FBS0EsU0FBU0csT0FBVCxDQUFpQkMsTUFBakIsRUFBeUJDLEdBQXpCLEVBQThCO0VBQzFCLEtBQUksSUFBSUMsSUFBUixJQUFnQkQsR0FBaEIsRUFBb0JULE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQk8sTUFBdEIsRUFBOEJFLElBQTlCLEVBQW9DO0lBQ3BEQyxVQUFVLEVBQUUsSUFEd0M7SUFFcERDLEdBQUcsRUFBRUgsR0FBRyxDQUFDQyxJQUFEO0VBRjRDLENBQXBDO0FBSXZCOztBQUNESCxPQUFPLENBQUNMLE9BQUQsRUFBVTtFQUNiLFdBQVMsb0JBQVc7SUFDaEIsT0FBT1csTUFBUDtFQUNILENBSFk7RUFJYlIsaUJBQWlCLEVBQUUsNkJBQVc7SUFDMUIsT0FBT0Esa0JBQVA7RUFDSCxDQU5ZO0VBT2JDLFNBQVMsRUFBRSxxQkFBVztJQUNsQixPQUFPQSxVQUFQO0VBQ0g7QUFUWSxDQUFWLENBQVA7O0FBV0EsSUFBTVEsd0JBQXdCLEdBQUdDLG1CQUFPLENBQUMsNEdBQUQsQ0FBeEM7O0FBQ0EsSUFBTUMseUJBQXlCLEdBQUdELG1CQUFPLENBQUMsOEdBQUQsQ0FBekM7O0FBQ0EsSUFBTUUsb0JBQW9CLEdBQUdGLG1CQUFPLENBQUMsZ0hBQUQsQ0FBcEM7O0FBQ0EsSUFBTUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHFGQUFELENBQTVCOztBQUNBLElBQU1JLE9BQU8sR0FBR0osbUJBQU8sQ0FBQyx5RUFBRCxDQUF2Qjs7QUFDQSxJQUFNSyxRQUFRLEdBQUcsYUFBY0oseUJBQXlCLENBQUNLLENBQTFCLENBQTRCTixtQkFBTyxDQUFDLHVFQUFELENBQW5DLENBQS9COztBQUNBLElB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U0FDRCxlQUFhO01BQ1QsT0FBTyxLQUFLdUssS0FBTCxDQUFXOUosTUFBbEI7SUFDSDs7O1NBQ0QsZUFBaUI7TUFDYixPQUFPLEtBQUs4SixLQUFMLENBQVdULFVBQWxCO0lBQ0g7OztTQUNELGVBQWdCO01BQ1osT0FBTyxLQUFLUyxLQUFMLENBQVdQLFNBQWxCO0lBQ0g7Ozs7O0FBeUxMLENBQUMsWUFBSTtFQUNEaE4sTUFBTSxDQUFDOFAsTUFBUCxHQUFnQixDQUFDLEdBQUduUCxLQUFLLFdBQVQsR0FBaEI7QUFDSCxDQUZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzPzg2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZWZhdWx0OiBudWxsLFxuICAgIG1hdGNoZXNNaWRkbGV3YXJlOiBudWxsLFxuICAgIGNyZWF0ZUtleTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlcjtcbiAgICB9LFxuICAgIG1hdGNoZXNNaWRkbGV3YXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNNaWRkbGV3YXJlO1xuICAgIH0sXG4gICAgY3JlYXRlS2V5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUtleTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVtb3ZldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IF9yb3V0ZWxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xuY29uc3QgX3NjcmlwdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvc2NyaXB0XCIpO1xuY29uc3QgX2lzZXJyb3IgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWVycm9yXCIpKTtcbmNvbnN0IF9kZW5vcm1hbGl6ZXBhZ2VwYXRoID0gcmVxdWlyZShcIi4uL3BhZ2UtcGF0aC9kZW5vcm1hbGl6ZS1wYWdlLXBhdGhcIik7XG5jb25zdCBfbm9ybWFsaXplbG9jYWxlcGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbmNvbnN0IF9taXR0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBfaXNkeW5hbWljID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IF9wYXJzZXJlbGF0aXZldXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xuY29uc3QgX3Jlc29sdmVyZXdyaXRlcyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG5jb25zdCBfcm91dGVtYXRjaGVyID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtbWF0Y2hlclwiKTtcbmNvbnN0IF9yb3V0ZXJlZ2V4ID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XG5jb25zdCBfZm9ybWF0dXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbmNvbnN0IF9kZXRlY3Rkb21haW5sb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2RldGVjdC1kb21haW4tbG9jYWxlXCIpO1xuY29uc3QgX3BhcnNlcGF0aCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXBhdGhcIik7XG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xuY29uc3QgX3JlbW92ZWxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmViYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9hZGRiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9pc2FwaXJvdXRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1hcGktcm91dGVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfY29tcGFyZXN0YXRlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBhcmUtc3RhdGVzXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfaXNib3QgPSByZXF1aXJlKFwiLi91dGlscy9pcy1ib3RcIik7XG5jb25zdCBfb21pdCA9IHJlcXVpcmUoXCIuL3V0aWxzL29taXRcIik7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLWhyZWZcIik7XG5jb25zdCBfaW50ZXJwb2xhdGVhcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsXCIpO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoXCJSb3V0ZSBDYW5jZWxsZWRcIiksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShvcHRpb25zLmFzUGF0aCk7XG4gICAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXG4gICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXNQYXRobmFtZSkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhc1BhdGhuYW1lKSA6IGFzUGF0aG5hbWU7XG4gICAgY29uc3QgYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgb3B0aW9ucy5sb2NhbGUpKTtcbiAgICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxuICAgIC8vIHdoZXJlIHdlIGNhbiBhY2Nlc3MgbW9yZSBpbmZvIHN1Y2ggYXMgaGVhZGVycywgSHR0cE9ubHkgY29va2llLCBldGMuXG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG0pPT5uZXcgUmVnRXhwKG0ucmVnZXhwKS50ZXN0KGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlKSk7XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzLmdldExvY2F0aW9uT3JpZ2luKSgpO1xuICAgIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcbiAgICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcztcbiAgICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZXYXNBYnNvbHV0ZSA/IHJlc29sdmVkSHJlZiA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4oKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLCBfZGVub3JtYWxpemVwYWdlcGF0aC5kZW5vcm1hbGl6ZVBhZ2VQYXRoKShwYXRobmFtZSkpO1xuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSBcIi80MDRcIiB8fCBjbGVhblBhdGhuYW1lID09PSBcIi9fZXJyb3JcIikge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFnZSkgJiYgKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhKHNvdXJjZSwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0Q29uZmlnID0ge1xuICAgICAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgfSxcbiAgICAgICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpXG4gICAgfTtcbiAgICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZXdyaXRlXCIpO1xuICAgIGxldCByZXdyaXRlVGFyZ2V0ID0gcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLW1hdGNoZWQtcGF0aFwiKTtcbiAgICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1tYXRjaGVkLXBhdGhcIik7XG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIl9fbmV4dF9kYXRhX2NhdGNoYWxsXCIpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIi9fZXJyb3JcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiLzQwNFwiKSkge1xuICAgICAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xuICAgIH1cbiAgICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKFwiL1wiKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkocmV3cml0ZVRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKClcbiAgICAgICAgICAgIF0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dID0gcGFyYW07XG4gICAgICAgICAgICAgICAgbGV0IGFzID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXRobmFtZUluZm8ucGF0aG5hbWUsIHBhdGhuYW1lSW5mby5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkoYXMpIHx8ICFyZXdyaXRlSGVhZGVyICYmIHBhZ2VzLmluY2x1ZGVzKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRTb3VyY2UgPSAoMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHNvdXJjZSkucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb25maWc6IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgPyB1bmRlZmluZWQgOiBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoYXMsIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgKHBhdGgpPT5yZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkgPyByZXNvbHZlRHluYW1pY1JvdXRlKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUsIHBhZ2VzKSA6IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyZXNvbHZlZEhyZWYpKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmV3cml0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBczogcGFyc2VkUmV3cml0ZVRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoc291cmNlKTtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8uZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoe1xuICAgICAgICAgICAgLi4uKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICBidWlsZElkOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtZXh0ZXJuYWxcIixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJlZGlyZWN0XCIpO1xuICAgIGlmIChyZWRpcmVjdFRhcmdldCkge1xuICAgICAgICBpZiAocmVkaXJlY3RUYXJnZXQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkocmVkaXJlY3RUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8uZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoe1xuICAgICAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICBidWlsZElkOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtaW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgICBuZXdBczogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2gsXG4gICAgICAgICAgICAgICAgbmV3VXJsOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiBcIm5leHRcIlxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmVFZmZlY3RzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucyk7XG4gICAgaWYgKCFtYXRjaGVzIHx8ICFvcHRpb25zLmZldGNoRGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IG9wdGlvbnMuZmV0Y2hEYXRhKCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IGF3YWl0IGdldE1pZGRsZXdhcmVEYXRhKGRhdGEuZGF0YUhyZWYsIGRhdGEucmVzcG9uc2UsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXG4gICAgICAgICAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgICAgICAgICByZXNwb25zZTogZGF0YS5yZXNwb25zZSxcbiAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgZWZmZWN0XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKipcbiAgICAgKiBUT0RPOiBSZXZpc2l0IHRoaXMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBGb3Igbm93IHdlIHdpbGwgbm90IGNvbnNpZGVyIG1pZGRsZXdhcmUgZGF0YSBlcnJvcnMgdG8gYmUgZmF0YWwuXG4gICAgICogbWF5YmUgd2Ugc2hvdWxkIHJldmlzaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKi8gcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJzY3JvbGxSZXN0b3JhdGlvblwiIGluIHdpbmRvdy5oaXN0b3J5ICYmICEhZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHYgPSBcIl9fbmV4dFwiO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlO1xuICAgIH0gY2F0Y2ggKG4pIHt9XG59KCk7XG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woXCJTU0dfREFUQV9OT1RfRk9VTkRcIik7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICBcIngtbmV4dGpzLWRhdGFcIjogXCIxXCJcbiAgICAgICAgfSlcbiAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpIDogcmVzcG9uc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHBhcmFtKSB7XG4gICAgbGV0IHsgZGF0YUhyZWYgLCBpbmZsaWdodENhY2hlICwgaXNQcmVmZXRjaCAsIGhhc01pZGRsZXdhcmUgLCBpc1NlcnZlclJlbmRlciAsIHBhcnNlSlNPTiAsIHBlcnNpc3RDYWNoZSAsIGlzQmFja2dyb3VuZCAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdmFyIF9wYXJhbXNfbWV0aG9kO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+e1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiBcInByZWZldGNoXCJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xuICAgICAgICAgICAgICAgIFwieC1taWRkbGV3YXJlLXByZWZldGNoXCI6IFwiMVwiXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6IFwiR0VUXCJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgMzAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA4XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdHJ5VG9QYXJzZUFzSlNPTiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJ5VG9QYXJzZUFzSlNPTi5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNcIik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtY2FjaGVcIikgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy8gY2hyb21lXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIHx8IC8vIHNhZmFyaVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gd2hlbiBza2lwcGluZyBjbGllbnQgY2FjaGUgd2Ugd2FpdCB0byB1cGRhdGVcbiAgICAvLyBpbmZsaWdodCBjYWNoZSB1bnRpbCBzdWNjZXNzZnVsIGRhdGEgcmVzcG9uc2VcbiAgICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXG4gICAgLy8gd2l0aG91dCBibG9ja2luZyBuYXZpZ2F0aW9uIHdoZW4gc3RhbGUgZGF0YSBpcyBhdmFpbGFibGVcbiAgICBpZiAodW5zdGFibGVfc2tpcENsaWVudENhY2hlICYmIHBlcnNpc3RDYWNoZSkge1xuICAgICAgICByZXR1cm4gZ2V0RGF0YSh7fSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGdldERhdGEoaXNCYWNrZ3JvdW5kID8ge1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiXG4gICAgfSA6IHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTApO1xufVxuZnVuY3Rpb24gaGFuZGxlSGFyZE5hdmlnYXRpb24ocGFyYW0pIHtcbiAgICBsZXQgeyB1cmwgLCByb3V0ZXIgIH0gPSBwYXJhbTtcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gICAgaWYgKHVybCA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgXCIgKyB1cmwgKyBcIiBcIiArIGxvY2F0aW9uLmhyZWYpO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgcm91dGUgLCByb3V0ZXIgIH0gPSBwYXJhbTtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCInICsgcm91dGUgKyAnXCInKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInB1c2hTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2JmbChhcywgcmVzb2x2ZWRBcywgbG9jYWxlLCBza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1ckFzIG9mIFtcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzXG4gICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwoY3VyQXMsIFwiaHR0cDovL25cIikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzTm9TbGFzaCwgbG9jYWxlIHx8IHRoaXMubG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc05vU2xhc2ggIT09ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKHRoaXMuYXNQYXRoLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfcywgX3RoaXNfX2JmbF9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfcy5jb250YWlucyhhc05vU2xhc2gpKSB8fCAhISgoX3RoaXNfX2JmbF9zMSA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5jb250YWlucyhhc05vU2xhc2hMb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyAhbWF0Y2hlc0JmbER5bmFtaWMgJiYgaSA8IGN1ckFzUGFydHMubGVuZ3RoICsgMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChfdGhpc19fYmZsX2QgPSB0aGlzLl9iZmxfZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfZC5jb250YWlucyhjdXJyZW50UGFydCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjbGllbnQgcm91dGVyIGZpbHRlciBpcyBtYXRjaGVkIHRoZW4gd2UgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIHZhciBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lO1xuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmwpKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSBvcHRpb25zLl9oID09PSAxO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gdGhpcy5pc1JlYWR5ICE9PSB0cnVlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc1NzciA9IHRoaXMuaXNTc3I7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyB0aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbG9jYWxlcztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKF90aGlzX2xvY2FsZXMgPSB0aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19sb2NhbGVzLmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cFwiICsgKGRldGVjdGVkRG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIiArIGRldGVjdGVkRG9tYWluLmRvbWFpbiArICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKFwiXCIgKyAobmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIG5leHRTdGF0ZS5sb2NhbGUpICsgKGFzTm9CYXNlUGF0aCA9PT0gXCIvXCIgPyBcIlwiIDogYXNOb0Jhc2VQYXRoKSB8fCBcIi9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJyb3V0ZUNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNoYWxsb3cgPWZhbHNlICwgc2Nyb2xsID10cnVlICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgdGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KG5leHRTdGF0ZSwgdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VDb21wbGV0ZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIGlmIHdlIGRldGVjdGVkIHRoZSBwYXRoIGFzIGFwcCByb3V0ZSBkdXJpbmcgcHJlZmV0Y2hpbmdcbiAgICAgICAgLy8gdHJpZ2dlciBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKChfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lID0gdGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUuX19hcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCksXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbWV0aG9kID0gXCJyZXBsYWNlU3RhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgICAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XG4gICAgICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAgICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lID8gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhdGhuYW1lKSkgOiBwYXRobmFtZTtcbiAgICAgICAgbGV0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgY29uc3QgcGFyc2VkQXNQYXRobmFtZSA9IGFzLnN0YXJ0c1dpdGgoXCIvXCIpICYmICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhcykucGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZVJld3JpdGUgPSAhIShwYXJzZWRBc1BhdGhuYW1lICYmIHJvdXRlICE9PSBwYXJzZWRBc1BhdGhuYW1lICYmICghKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSB8fCAhKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpKShwYXJzZWRBc1BhdGhuYW1lKSkpO1xuICAgICAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gIW9wdGlvbnMuc2hhbGxvdyAmJiBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhyZWY6IFwiJyArIHVybCArICdcIiBhbmQgYXM6IFwiJyArIGFzICsgJ1wiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhcycgKyBcIlxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgbGV0IHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgICAgICAgICByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXSAmJiAhcm91dGVSZWdleC5ncm91cHNbcGFyYW1dLm9wdGlvbmFsKTtcbiAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiSW50ZXJwb2xhdGluZyBocmVmXCIgOiBcIk1pc21hdGNoaW5nIGBhc2AgYW5kIGBocmVmYFwiKSArIFwiIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIFwiICsgKFwidGhlIHBhcmFtczogXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiIGluIHRoZSBgaHJlZmAncyBgcXVlcnlgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gXCJUaGUgcHJvdmlkZWQgYGhyZWZgIChcIiArIHVybCArIFwiKSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiKSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIFwiIDogXCJUaGUgcHJvdmlkZWQgYGFzYCB2YWx1ZSAoXCIgKyBhc1BhdGhuYW1lICsgXCIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBgaHJlZmAgdmFsdWUgKFwiICsgcm91dGUgKyBcIikuIFwiKSArIChcIlJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcImhyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWRcIiA6IFwiaW5jb21wYXRpYmxlLWhyZWYtYXNcIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdC5vbWl0KShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFcnJvclJvdXRlID0gdGhpcy5wYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgdGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcywgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMsIF9yb3V0ZUluZm9fcHJvcHM7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIFwicmVzb2x2ZWRBc1wiIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInJvdXRlXCIgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA6IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9ICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXMgPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkobmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlQXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocmV3cml0ZUFzLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcm91dGVJbmZvLmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xuICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3NjcmlwdC5oYW5kbGVDbGllbnRTY3JpcHRMb2FkKShzY3JpcHQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcyAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoXCIvXCIpICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXJvdXRlSW5mby5wcm9wcy5fX05fUFJFVklFVztcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvNDA0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSBcIi9fZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vdEZvdW5kOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb3V0ZUluZm9fcm91dGU7XG4gICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKChfcm91dGVJbmZvX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlSW5mb19yb3V0ZSA6IHJvdXRlKTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9uc19zY3JvbGw7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAoX29wdGlvbnNfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfb3B0aW9uc19zY3JvbGwgOiAhaXNRdWVyeVVwZGF0aW5nICYmICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAgICAgICAvLyBxdWVyeSBwYXJhbWV0ZXJzLiBSb3V0ZSBjaGFuZ2VzIGhlcmUgbWlnaHQgYWRkIHRoZSBiYXNlUGF0aCB3aGVuIGl0XG4gICAgICAgICAgICAvLyB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50LiBUaGlzIGlzIGFsc28gd2h5IHRoaXMgYmxvY2sgaXMgYmVmb3JlIHRoZVxuICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIFVSTCkuXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzRXJyb3JSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSwgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLCBfcm91dGVJbmZvX3Byb3BzMTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiBcIiArIHRoaXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgJiYgKChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMS5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMxID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wczEucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiYmVmb3JlSGlzdG9yeUNoYW5nZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBmb3IgcXVlcnkgdXBkYXRlcyB3ZSBjYW4gc2tpcCBpdCBpZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcbiAgICAgICAgICAgIGNvbnN0IGNhblNraXBVcGRhdGluZyA9IGlzUXVlcnlVcGRhdGluZyAmJiAhdXBjb21pbmdTY3JvbGxTdGF0ZSAmJiAhcmVhZHlTdGF0ZUNoYW5nZSAmJiAhbG9jYWxlQ2hhbmdlICYmICgwLCBfY29tcGFyZXN0YXRlcy5jb21wYXJlUm91dGVyU3RhdGVzKSh1cGNvbWluZ1JvdXRlclN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCByb3V0ZUluZm8uZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcm91dGVJbmZvLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC87XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LlwiICsgbWV0aG9kICsgXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJwdXNoU3RhdGVcIiB8fCAoMCwgX3V0aWxzLmdldFVSTCkoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXkgPSBtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgIFwiXCIsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIF9yb3V0ZWxvYWRlci5pc0Fzc2V0RXJyb3IpKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi9fZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiBcIiwgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzZXJyb3IuZGVmYXVsdCkocm91dGVJbmZvRXJyKSA/IHJvdXRlSW5mb0VyciA6IG5ldyBFcnJvcihyb3V0ZUluZm9FcnIgKyBcIlwiKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHBhcmFtKSB7XG4gICAgICAgIGxldCB7IHJvdXRlOiByZXF1ZXN0ZWRSb3V0ZSAsIHBhdGhuYW1lICwgcXVlcnkgLCBhcyAsIHJlc29sdmVkQXMgLCByb3V0ZVByb3BzICwgbG9jYWxlICwgaGFzTWlkZGxld2FyZSAsIGlzUHJldmlldyAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAsIGlzUXVlcnlVcGRhdGluZyAsIGlzTWlkZGxld2FyZVJld3JpdGUgLCBpc05vdEZvdW5kICB9ID0gcGFyYW07XG4gICAgICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi8gbGV0IHJvdXRlID0gcmVxdWVzdGVkUm91dGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKFwiaW5pdGlhbFwiIGluIGV4aXN0aW5nSW5mbykgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiA/IGV4aXN0aW5nSW5mbyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcbiAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gXCIvNDA0XCIgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIHVuLW5lY2Vzc2FyeSBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGZhdGFsXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgZmFsbGJhY2sgcm91dGUgYW5kIHRoZSBwcm9wcyBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgICAgIC8vIGVmZmVjdHNcbiAgICAgICAgICAgIGlmIChkYXRhICYmIChwYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgfHwgcGF0aG5hbWUgPT09IFwiLzQwNFwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIiB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDEudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmVmZmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDIgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDIudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2FwaXJvdXRlLmlzQVBJUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIicgKyBwYXRobmFtZSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhc0JhaWxlZFByZWZldGNoID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX3Jlc3BvbnNlID0gZGF0YS5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLXNraXBcIik7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgIC8vIEZvciBub24tU1NHIHByZWZldGNoZXMgdGhhdCBiYWlsZWQgYmVmb3JlIHNlbmRpbmcgZGF0YVxuICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzICwgY2FjaGVLZXkgIH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgJiYgIXdhc0JhaWxlZFByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBkYXRhLmpzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUhyZWYgPSAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikgPyBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkID0gYXdhaXQgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogd2FzQmFpbGVkUHJlZmV0Y2ggPyB7fSA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZmV0Y2hlZC5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhyb3V0ZUluZm8uQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE9ubHkgYnVzdCB0aGUgZGF0YSBjYWNoZSBmb3IgU1NQIHJvdXRlcyBhbHRob3VnaFxuICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAgICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcbiAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uX19OX1NTUCAmJiBmZXRjaE5leHREYXRhUGFyYW1zLmRhdGFIcmVmICYmIGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgJiYgIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2JjXG4gICAgICAgICAgICAgICAgfSkpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdChcIiNcIik7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSBcIlwiXSA9IGFzLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09IFwiXCIgfHwgaGFzaCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+d2luZG93LnNjcm9sbFRvKDAsIDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaCk7XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PmlkRWwuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+bmFtZUVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gYXN5bmMgcHJlZmV0Y2godXJsLCBhc1BhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFzUGF0aCA9PT0gdm9pZCAwKSBhc1BhdGggPSB1cmw7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgKDAsIF9pc2JvdC5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAvLyBObyBwcmVmZXRjaGVzIGZvciBib3RzIHRoYXQgcmVuZGVyIHRoZSBsaW5rIHNpbmNlIHRoZXkgYXJlIHR5cGljYWxseSBuYXZpZ2F0aW5nXG4gICAgICAgICAgICAvLyBsaW5rcyB2aWEgdGhlIGVxdWl2YWxlbnQgb2YgYSBoYXJkIG5hdmlnYXRpb24gYW5kIGhlbmNlIG5ldmVyIHV0aWxpemUgdGhlc2VcbiAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICBjb25zdCB1cmxQYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogdGhpcy5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfSA9IGF3YWl0ICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSk7XG4gICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKCgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNQYXRoLCB0aGlzLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFyc2VkLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhcnNlZC5wYXRobmFtZSkpKCgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXNQYXRoKS5wYXRobmFtZSkgfHwge30pO1xuICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCA9PT0gXCJzdHJpY3RcIiA/IG51bGwgOiBhd2FpdCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSB3YXMgYSByZXdyaXRlIHdlIGFwcGx5IHRoZSBlZmZlY3RzIG9mIHRoZSByZXdyaXRlIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgcGFyYW1ldGVycyBmb3IgdGhlIHByZWZldGNoLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgdG8gYW4gZXh0ZXJuYWwgZGVzdGluYXRpb24gdGhlbiB3ZSBkb24ndCBoYXZlXG4gICAgICogdG8gcHJlZmV0Y2ggY29udGVudCBhcyBpdCB3aWxsIGJlIHVudXNlZC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZWRpcmVjdC1leHRlcm5hbFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5fYmZsKGFzUGF0aCwgcmVzb2x2ZWRBcywgb3B0aW9ucy5sb2NhbGUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdXJsUGF0aG5hbWVdID0ge1xuICAgICAgICAgICAgICAgIF9fYXBwUm91dGVyOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgPyBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlIHx8IG9wdGlvbnMucHJpb3JpdHkgJiYgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEVcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkuY2F0Y2goKCk9PmZhbHNlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/IFwibG9hZFBhZ2VcIiA6IFwicHJlZmV0Y2hcIl0ocm91dGUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsYyA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIkxvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2VKU09OOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlXG4gICAgICAgIH0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgdGV4dCAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgIH0gPSB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCByb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGU7XG4gICAgfVxuICAgIGdldCBwYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGdldCBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnk7XG4gICAgfVxuICAgIGdldCBhc1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aDtcbiAgICB9XG4gICAgZ2V0IGxvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xuICAgIH1cbiAgICBnZXQgaXNGYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFjaztcbiAgICB9XG4gICAgZ2V0IGlzUHJldmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZSwgcXVlcnksIGFzLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50ICwgZXJyICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2RjID0ge307XG4gICAgICAgIC8vIFNlcnZlciBCYWNrZ3JvdW5kIENhY2hlIChIRUFEIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNiYyA9IHt9O1xuICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fa2V5ID0gY3JlYXRlS2V5KCk7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzLmdldFVSTCkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgICAgICAgICAgaWYgKHN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgcG9wc3RhdGVldmVudCB3aGVuIHJlb3BlbmluZyB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0UG9wU3RhdGVFdmVudCAmJiB0aGlzLmxvY2FsZSA9PT0gc3RhdGUub3B0aW9ucy5sb2NhbGUgJiYgc3RhdGUuYXMgPT09IHRoaXMuYXNQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwga2V5ICB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMuYXNQYXRoKSAmJiBwYXRobmFtZSA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgICAgICAgICAgX2g6IDBcbiAgICAgICAgICAgIH0pLCBmb3JjZWRTY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl0gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL2Jsb29tLWZpbHRlclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUjtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVI7XG4gICAgICAgICAgICBpZiAoc3RhdGljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGljRmlsdGVyRGF0YS5udW1IYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihzdGF0aWNGaWx0ZXJEYXRhLm51bUl0ZW1zLCBzdGF0aWNGaWx0ZXJEYXRhLmVycm9yUmF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5udW1IYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5udW1JdGVtcywgZHluYW1pY0ZpbHRlckRhdGEuZXJyb3JSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZC5pbXBvcnQoZHluYW1pY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISEoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgICAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWFzLnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc1BhdGggPSAoMCwgX3V0aWxzLmdldFVSTCkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoXG4gICAgICAgICAgICAgICAgfSkudGhlbigobWF0Y2hlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhcyAhPT0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgbWF0Y2hlcyA/IGFzUGF0aCA6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSksIGFzUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuICAgICAgICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbigoKT0+e1xuICAgIFJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQuZGVmYXVsdCkoKTtcbn0pKCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJtYXRjaGVzTWlkZGxld2FyZSIsImNyZWF0ZUtleSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJfcm91dGVsb2FkZXIiLCJfc2NyaXB0IiwiX2lzZXJyb3IiLCJfIiwiX2Rlbm9ybWFsaXplcGFnZXBhdGgiLCJfbm9ybWFsaXplbG9jYWxlcGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzZHluYW1pYyIsIl9wYXJzZXJlbGF0aXZldXJsIiwiX3Jlc29sdmVyZXdyaXRlcyIsIl9yb3V0ZW1hdGNoZXIiLCJfcm91dGVyZWdleCIsIl9mb3JtYXR1cmwiLCJfZGV0ZWN0ZG9tYWlubG9jYWxlIiwiX3BhcnNlcGF0aCIsIl9hZGRsb2NhbGUiLCJfcmVtb3ZlbG9jYWxlIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2FkZGJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX2lzYXBpcm91dGUiLCJfZ2V0bmV4dHBhdGhuYW1laW5mbyIsIl9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvIiwiX2NvbXBhcmVzdGF0ZXMiLCJfaXNsb2NhbHVybCIsIl9pc2JvdCIsIl9vbWl0IiwiX3Jlc29sdmVocmVmIiwiX2ludGVycG9sYXRlYXMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImFzc2lnbiIsIkVycm9yIiwiY2FuY2VsbGVkIiwib3B0aW9ucyIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJtYXRjaGVycyIsInBhcnNlUGF0aCIsImFzUGF0aCIsImFzUGF0aG5hbWUiLCJwYXRobmFtZSIsImNsZWFuZWRBcyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVIcmVmIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJwYXJhbSIsInJld3JpdGVzIiwiX19yZXdyaXRlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXJzZWRTb3VyY2UiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwidW5kZWZpbmVkIiwicmVzdWx0IiwicXVlcnkiLCJwYXRoIiwibWF0Y2hlZFBhZ2UiLCJwYXJzZWRBcyIsInJlc29sdmVkUGF0aG5hbWUiLCJtYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwidHlwZSIsInNyYyIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJkZWZhdWx0TG9jYWxlIiwiYnVpbGRJZCIsImRlc3RpbmF0aW9uIiwiaGFzaCIsInJlZGlyZWN0VGFyZ2V0IiwibmV3QXMiLCJuZXdVcmwiLCJ3aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJmZXRjaERhdGEiLCJkYXRhIiwiZGF0YUhyZWYiLCJlZmZlY3QiLCJqc29uIiwidGV4dCIsImNhY2hlS2V5IiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJfX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OIiwid2luZG93IiwiaGlzdG9yeSIsInYiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibiIsIlNTR19EQVRBX05PVF9GT1VORCIsIlN5bWJvbCIsImZldGNoUmV0cnkiLCJhdHRlbXB0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJvayIsInN0YXR1cyIsInRyeVRvUGFyc2VBc0pTT04iLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImZldGNoTmV4dERhdGEiLCJpbmZsaWdodENhY2hlIiwiaXNQcmVmZXRjaCIsImhhc01pZGRsZXdhcmUiLCJpc1NlcnZlclJlbmRlciIsInBhcnNlSlNPTiIsInBlcnNpc3RDYWNoZSIsImlzQmFja2dyb3VuZCIsInVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsIl9wYXJhbXNfbWV0aG9kIiwiZ2V0RGF0YSIsInBhcmFtcyIsInB1cnBvc2UiLCJfdHJ5VG9QYXJzZUFzSlNPTiIsIm5vdEZvdW5kIiwibWFya0Fzc2V0RXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsImluaXRpYWxQcm9wcyIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInNkYyIsInNiYyIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50IiwiX2tleSIsIm9uUG9wU3RhdGUiLCJlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwibnVtSGFzaGVzIiwiX2JmbF9zIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJfYmZsX2QiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJza2lwTmF2aWdhdGUiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJjdXJBcyIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsIl90aGlzX19iZmxfcyIsImNvbnRhaW5zIiwiX3RoaXNfX2JmbF9zMSIsIm5vcm1hbGl6ZWRBUyIsImN1ckFzUGFydHMiLCJzcGxpdCIsImkiLCJjdXJyZW50UGFydCIsImpvaW4iLCJfdGhpc19fYmZsX2QiLCJpc0xvY2FsVVJMIiwiaXNRdWVyeVVwZGF0aW5nIiwiX2JmbCIsInNob3VsZFJlc29sdmVIcmVmIiwibmV4dFN0YXRlIiwicmVhZHlTdGF0ZUNoYW5nZSIsInByZXZMb2NhbGUiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkaWROYXZpZ2F0ZSIsIl90aGlzX2xvY2FsZXMiLCJkZXRlY3RlZERvbWFpbiIsImRvbWFpbiIsImFzTm9CYXNlUGF0aCIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJfaW5GbGlnaHRSb3V0ZSIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJzY3JvbGxUb0hhc2giLCJzZXQiLCJwYXJzZWQiLCJfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lIiwiX19hcHBSb3V0ZXIiLCJ1cmxJc05ldyIsInBhcnNlZEFzUGF0aG5hbWUiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJleHRlcm5hbERlc3QiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwibWlzc2luZ1BhcmFtcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJvcHRpb25hbCIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCIsImlzRXJyb3JSb3V0ZSIsImdldFJvdXRlSW5mbyIsInJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsImZvckVhY2giLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsImNvbXBvbmVudCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsInNjcmlwdHMiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsInBhcnNlZEhyZWYiLCJfX05fUFJFVklFVyIsImZldGNoQ29tcG9uZW50Iiwibm90Rm91bmRSb3V0ZSIsImlzTm90Rm91bmQiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMiLCJzdGF0dXNDb2RlIiwiX3JvdXRlSW5mb19wcm9wcyIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfcm91dGVJbmZvX3JvdXRlIiwic2hvdWxkU2Nyb2xsIiwiX29wdGlvbnNfc2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1Njcm9sbFN0YXRlIiwidXBjb21pbmdSb3V0ZXJTdGF0ZSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxIiwiX3JvdXRlSW5mb19wcm9wczEiLCJjYW5Ta2lwVXBkYXRpbmciLCJjb21wYXJlUm91dGVyU3RhdGVzIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJsYW5nIiwiaGFzaFJlZ2V4IiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwicmVxdWVzdGVkUm91dGUiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsIl9kYXRhX2VmZmVjdCIsIl9kYXRhX2VmZmVjdDEiLCJfZGF0YV9lZmZlY3QyIiwicmVzb2x2ZWRSb3V0ZSIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ3YXNCYWlsZWRQcmVmZXRjaCIsIl9kYXRhX3Jlc3BvbnNlIiwic2hvdWxkRmV0Y2hEYXRhIiwiX2dldERhdGEiLCJmZXRjaGVkIiwiZ2V0UHJvcGVyRXJyb3IiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJyYXdIYXNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXJsUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGhuYW1lIiwiX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0giLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFIiwibG9hZFBhZ2UiLCJjb21wb25lbnRSZXN1bHQiLCJmbiIsImN0eCIsIkFwcFRyZWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});